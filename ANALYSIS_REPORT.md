# 네이버 플레이스 ADLOG 알고리즘 역추적 분석 보고서

## 분석 대상
- **사이트/서비스**: 네이버 플레이스 (ADLOG 순위 알고리즘)
- **분석 목표**: N1, N2, N3 값과 순위의 관계 파악, 숨겨진 공식 도출
- **데이터**: 6개 키워드 x 10개 업체 = 60개 샘플

## 수집된 데이터 요약

| 키워드 | 유형 | N1 특성 | 샘플 수 |
|--------|------|---------|---------|
| 홍대맛집 | Type A | 고정 (0.366894) | 10 |
| 강남카페 | Type A | 고정 (0.397269) | 10 |
| 부산반지공방 | Type A | 고정 (0.456679) | 10 |
| 성수브런치 | Type B | 가변 (0.561~0.570) | 10 |
| 이태원술집 | Type B | 가변 (0.555~0.563) | 10 |
| 대전고기집 | Type B | 가변 (0.512~0.545) | 10 |

---

## 핵심 발견

### 1. 키워드 유형 분류

**유형 판별 기준**: N1 표준편차
- N1 std < 0.001 → **Type A** (N1 고정)
- N1 std > 0.001 → **Type B** (N1 가변)

| 유형 | 키워드 예시 | N1 특성 | 순위 결정 요소 |
|------|-------------|---------|----------------|
| Type A | 맛집, 카페, 공방 | 고정값 | N2 또는 N3 |
| Type B | 브런치, 술집, 고기집 | 가변 | N1 또는 N3 |

### 2. 순위 결정 요소

| 키워드 | N1-순위 상관 | N2-순위 상관 | N3-순위 상관 | **주 결정 요소** |
|--------|-------------|-------------|-------------|-----------------|
| 홍대맛집 | NaN (고정) | **1.0000** | **1.0000** | N2/N3 |
| 강남카페 | NaN (고정) | **1.0000** | **1.0000** | N2/N3 |
| 부산반지공방 | NaN (고정) | **1.0000** | **1.0000** | N2/N3 |
| 성수브런치 | **1.0000** | -0.3333 | 0.8424 | **N1** |
| 이태원술집 | 0.2485 | 0.8061 | **1.0000** | **N3** |
| 대전고기집 | 0.9758 | 0.7818 | **1.0000** | **N3** |

---

## 도출된 공식

### Type A 공식 (맛집, 카페, 반지공방)

```
N1 = 키워드별 고정값
  - 맛집 계열: 0.366894
  - 카페 계열: 0.397269
  - 공방 계열: 0.456679

N2 = -0.020450 * log(V+1)
     + 0.011707 * log(B+1)
     + 0.046951 * log(S+1)
     + 0.138907

R² = 0.8868 (88.68% 설명력)

순위 = N2 높은 순서 (완벽 상관)
```

**Type A N3 공식**:
```
N3 = -0.255112*N1 + -0.137087*N2 + 0.932150*N1*N2 + 0.381767
R² = 0.9613
```

### Type B 공식 (브런치, 술집, 고기집)

```
N1_base = -0.000844 * log(V+1)
         + 0.012809 * log(B+1)
         + 0.001403 * log(S+1)
         + 0.460640

R² = 0.7160 (71.60% 설명력)

N1 = N1_base + Quality_Score (숨겨진 요소)

순위:
  - 브런치: N1 높은 순
  - 술집/고기집: N3 높은 순
```

**Type B N3 공식**:
```
N3 = 1.386800*N1 + 1.294721*N2 - 2.227913*N1*N2 - 0.380973
R² = 0.9350
```

---

## 숨겨진 요소 분석 (Quality_Score)

### 정의
```
Quality_Score = N1_actual - N1_predicted
             = N1 - (a*log(V+1) + b*log(B+1) + c*log(S+1) + d)
```

### 특성

| 항목 | 값 |
|------|-----|
| 범위 | -0.019 ~ +0.017 |
| 평균 | 0 |
| 표준편차 | 0.0104 |
| 순위와 상관 | 0.46 |
| V, B, S와 상관 | ~0 (독립적) |

### 키워드별 Quality_Score

| 키워드 | Q_Score vs 순위 상관 |
|--------|---------------------|
| 성수브런치 | 0.2727 |
| 이태원술집 | 0.6970 |
| 대전고기집 | 0.5030 |

### 가능한 정체 (추정)

1. **별점 (Rating)**: 가장 유력
   - Quality_Score 범위를 4.0~5.0 별점으로 역산 시 합리적
   - 추정 공식: `Quality_Score = 0.0356 * (Rating - 4.5)`

2. **CTR (클릭률)**: 네이버만 접근 가능
3. **체류 시간**: 네이버만 접근 가능
4. **리뷰 품질 점수**: 텍스트 분석 기반

---

## 역산 결과: 추정 별점

| 키워드 | 순위 | 업체명 | Quality_Score | 추정 별점 |
|--------|------|--------|---------------|----------|
| 성수브런치 | 1 | 쎄콩데live | +0.0087 | 4.74 |
| 성수브런치 | 2 | 메이플탑 | +0.0052 | 4.65 |
| 성수브런치 | 3 | 써니눅 성수 | +0.0141 | 4.90 |
| 이태원술집 | 1 | 이태원사랑방 | +0.0039 | 4.61 |
| 이태원술집 | 2 | 마가진상회 | +0.0154 | 4.93 |
| 대전고기집 | 1 | 돼지명가 | +0.0090 | 4.75 |
| 대전고기집 | 2 | 고반 | +0.0051 | 4.64 |
| 대전고기집 | 3 | 불백마을 | -0.0132 | 4.13 |

---

## V, B, S로 직접 순위 예측 가능성

| 키워드 | V,B,S→순위 상관 | 예측 가능성 |
|--------|----------------|------------|
| 홍대맛집 | 0.8909 | 높음 |
| 강남카페 | 0.6970 | 중간 |
| 부산반지공방 | 0.7939 | 높음 |
| 성수브런치 | 0.7576 | 높음 |
| 이태원술집 | 0.8061 | 높음 |
| 대전고기집 | 0.6121 | 중간 |

---

## 문제점 분석

### Type A 문제: N2 예측은 되는데 순위 상관이 낮은 경우

**원인**: 상위 업체들의 N2 값 차이가 매우 작음

| 키워드 | N2 범위 | N2 순위간 평균 차이 |
|--------|---------|-------------------|
| 홍대맛집 | 0.0457 | 0.0051 |
| 강남카페 | 0.0257 | 0.0029 |
| 부산반지공방 | 0.0345 | 0.0038 |

**해결책**:
1. 더 정밀한 계수 도출 필요
2. 추가 변수 탐색 (V*B 상호작용 등)
3. V/(V+B) 비율 추가 시 정확도 향상

### Type B 문제: N1 예측 R² = 72%

**원인**: 28%가 숨겨진 요소 (Quality_Score)

**해결책**:
1. 별점 데이터 크롤링 후 공식에 포함
2. Quality_Score를 업체별로 저장하고 재사용

---

## 실용적 적용 방법

### 1. 새 업체 순위 예측

```python
# Type 판별
if N1_std < 0.001:
    keyword_type = "A"
else:
    keyword_type = "B"

# Type A
if keyword_type == "A":
    N1 = KEYWORD_N1_MAP[keyword]  # 사전 정의된 값
    N2 = -0.020450 * np.log1p(V) + 0.011707 * np.log1p(B) + 0.046951 * np.log1p(S) + 0.138907
    predicted_rank = based_on(N2)  # N2 높을수록 상위

# Type B
else:
    N1_base = -0.000844 * np.log1p(V) + 0.012809 * np.log1p(B) + 0.001403 * np.log1p(S) + 0.460640
    quality_score = 0  # 새 업체는 기본값 0
    N1 = N1_base + quality_score
    # 브런치: N1 기준, 술집/고기집: N3 기준
```

### 2. 기존 업체 분석

```python
# ADLOG에서 실제 N1 값 확인
actual_N1 = get_from_adlog(place_id)

# Quality_Score 계산
N1_base = calculate_N1_base(V, B, S)
quality_score = actual_N1 - N1_base

# 이 값을 저장해두면 향후 예측에 사용 가능
save_quality_score(place_id, quality_score)
```

---

## 검증 결과

| 항목 | Type A | Type B |
|------|--------|--------|
| N2 예측 R² | 88.68% | - |
| N1 예측 R² | - | 71.60% |
| N3 예측 R² | 96.13% | 93.50% |
| 순위 예측 상관 | 0.73~0.93 | 0.61~0.81 |

### 예외 케이스

- **강남카페**: N2 순위 예측 상관이 0.72로 낮음 (다른 요소 존재 가능)
- **대전고기집**: V,B,S→순위 상관이 0.61로 낮음 (Quality_Score 영향 큼)

---

## 결론

1. **ADLOG 알고리즘은 두 가지 유형으로 작동**
   - Type A (N1 고정): N2가 순위 결정
   - Type B (N1 가변): 키워드에 따라 N1 또는 N3가 순위 결정

2. **숨겨진 요소 존재 확인**
   - Type B에서 N1의 28%는 V, B, S로 설명 불가
   - 가장 유력한 후보: 별점 (Rating)

3. **순위 예측 가능**
   - V, B, S만으로 60~90% 순위 예측 가능
   - 별점 데이터 추가 시 정확도 향상 예상

4. **다음 단계**
   - 별점 데이터 크롤링 및 상관 분석
   - 더 많은 키워드로 패턴 검증
   - 시간에 따른 변화 추적

---

## 분석 파일 위치

- `/Users/songminseung/place-analytics/deep_analysis.py`: 1차 심층 분석
- `/Users/songminseung/place-analytics/deep_analysis_v2.py`: 2차 심층 분석
- `/Users/songminseung/place-analytics/final_analysis.py`: 최종 분석

---

*분석 일자: 2026-01-10*
*분석 도구: Python (numpy, scipy)*
